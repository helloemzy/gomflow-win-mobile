# DROPWAVE: Technical Architecture Blueprint
## From Zero to Series A - The Pragmatic Path

---

## 🎯 ARCHITECTURAL PRINCIPLES

### The Non-Negotiables
1. **Ship Friday, Scale Monday** - Build for 1,000 users, architect for 1,000,000
2. **Boring is Beautiful** - Use proven, boring tech for critical paths
3. **Security by Default** - Every line of code assumes hostile input
4. **Break Gracefully** - Degrade, don't die
5. **Monitor Everything** - If you can't measure it, it will break at 3am

### The Anti-Patterns We're Avoiding
- ❌ Microservices for MVP (monolith first, extract later)
- ❌ Custom authentication (use Clerk/Auth0)
- ❌ Building our own payment infrastructure
- ❌ Premature optimization
- ❌ Resume-driven development
- ❌ "We'll add monitoring later"

---

## 🏗️ SYSTEM ARCHITECTURE

### The Stack (MVP - First 6 Months)
```
┌─────────────────────────────────────────┐
│           CloudFlare (CDN/DDoS)         │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│         Vercel Edge Functions           │
│            (API Routes)                 │
└────────────────┬────────────────────────┘
                 │
┌────────────────▼────────────────────────┐
│          Next.js 14 (App)               │
│     React Server Components              │
└────────┬──────────────┬─────────────────┘
         │              │
┌────────▼──────┐  ┌───▼──────────────────┐
│  Supabase     │  │  Stripe Connect      │
│  (PostgreSQL) │  │  (Payments)          │
│  (Realtime)   │  │                      │
└───────────────┘  └──────────────────────┘
```

### Why This Stack?

**Next.js + Vercel:**
- Deploy in 30 seconds
- Automatic scaling
- Edge functions for API
- Built-in image optimization
- ISR for campaign pages (SEO)

**Supabase:**
- PostgreSQL without DevOps
- Real-time subscriptions built-in
- Row Level Security (RLS)
- Automatic backups
- Auth included (but we'll use Clerk)

**Stripe Connect:**
- Handles ALL payment complexity
- PCI compliance out of the box
- Fraud detection included
- Global payments
- Automatic tax calculation

**Cloudflare:**
- DDoS protection
- Global CDN
- Zero-trust security
- $20/month to start

---

## 💾 DATA ARCHITECTURE

### Core Schema (PostgreSQL)
```sql
-- Keep it simple, denormalize where it makes sense
-- Every table has created_at, updated_at

-- Users (via Clerk, synced)
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  clerk_id TEXT UNIQUE NOT NULL,
  phone TEXT UNIQUE,
  tiktok_handle TEXT,
  stripe_account_id TEXT,
  verified BOOLEAN DEFAULT false,
  onboarding_completed BOOLEAN DEFAULT false,
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Campaigns (denormalized for read speed)
CREATE TABLE campaigns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id),
  slug TEXT UNIQUE NOT NULL, -- URL friendly
  
  -- Product Info
  title TEXT NOT NULL,
  description TEXT,
  price_cents INTEGER NOT NULL,
  images JSONB NOT NULL, -- Array of URLs
  
  -- Campaign Rules
  min_orders INTEGER NOT NULL,
  current_orders INTEGER DEFAULT 0, -- Denormalized counter
  deadline TIMESTAMPTZ NOT NULL,
  status TEXT CHECK (status IN ('draft','active','successful','failed','cancelled')),
  
  -- Customization
  theme JSONB NOT NULL, -- Entire theme config
  
  -- Analytics (denormalized)
  view_count INTEGER DEFAULT 0,
  share_count INTEGER DEFAULT 0,
  conversion_rate DECIMAL(5,2),
  
  -- Metadata
  metadata JSONB DEFAULT '{}',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- Indexes for performance
  INDEX idx_status (status),
  INDEX idx_deadline (deadline),
  INDEX idx_user_campaigns (user_id, status)
);

-- Orders (write-heavy, optimize for inserts)
CREATE TABLE orders (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  campaign_id UUID REFERENCES campaigns(id),
  
  -- Buyer info (no account required)
  email TEXT,
  phone TEXT,
  buyer_number INTEGER NOT NULL, -- "You're buyer #24"
  
  -- Payment
  stripe_payment_intent_id TEXT UNIQUE,
  amount_cents INTEGER NOT NULL,
  status TEXT CHECK (status IN ('pending','authorized','captured','refunded','failed')),
  
  -- Tracking
  referral_code TEXT,
  source TEXT, -- tiktok, instagram, direct
  
  created_at TIMESTAMPTZ DEFAULT NOW(),
  
  INDEX idx_campaign_orders (campaign_id, status),
  INDEX idx_stripe_lookup (stripe_payment_intent_id)
);

-- Real-time Events (for activity feed)
CREATE TABLE events (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  campaign_id UUID REFERENCES campaigns(id),
  type TEXT NOT NULL, -- order_placed, milestone_reached, etc
  data JSONB,
  created_at TIMESTAMPTZ DEFAULT NOW()
) PARTITION BY RANGE (created_at); -- Partition old events
```

### Critical Design Decisions

1. **Denormalized Counters**
   ```sql
   -- Don't COUNT(*) on every page load
   UPDATE campaigns 
   SET current_orders = current_orders + 1 
   WHERE id = $1;
   ```

2. **JSONB for Flexibility**
   ```sql
   -- Theme changes frequently, don't normalize
   theme: {
     colors: {...},
     fonts: {...},
     customCSS: "..."
   }
   ```

3. **Partition Events Table**
   ```sql
   -- Auto-archive old events to cold storage
   CREATE TABLE events_2024_01 PARTITION OF events
   FOR VALUES FROM ('2024-01-01') TO ('2024-02-01');
   ```

---

## 🔐 SECURITY ARCHITECTURE

### Layer 1: Network Security
```yaml
Cloudflare:
  - Rate limiting: 100 req/min per IP
  - DDoS protection: Always on
  - WAF rules: OWASP Top 10
  - Bot detection: Challenge suspicious traffic
```

### Layer 2: Application Security
```typescript
// Every input sanitized
import { z } from 'zod';

const CampaignSchema = z.object({
  title: z.string().min(1).max(100).regex(/^[^<>]*$/), // No HTML
  price_cents: z.number().min(100).max(1000000), // $1 - $10,000
  min_orders: z.number().min(5).max(10000),
});

// Row Level Security in Supabase
CREATE POLICY "Users can only update own campaigns"
ON campaigns FOR UPDATE
USING (auth.uid() = user_id);
```

### Layer 3: Payment Security
```typescript
// NEVER touch card details
// Stripe handles everything
const paymentIntent = await stripe.paymentIntents.create({
  amount: price_cents,
  currency: 'usd',
  capture_method: 'manual', // Don't charge until campaign succeeds
  metadata: {
    campaign_id: campaign.id,
    buyer_email: email // For refunds
  }
});
```

### Layer 4: Custom CSS Sandboxing
```typescript
// CSS injection security
import { sanitizeCSS } from './security/css-sanitizer';

const sanitizeCustomCSS = (css: string) => {
  // Remove any JavaScript
  css = css.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
  css = css.replace(/javascript:/gi, '');
  css = css.replace(/on\w+\s*=/gi, '');
  
  // Remove external requests
  css = css.replace(/@import/gi, '');
  css = css.replace(/url\s*\(/gi, (match) => {
    // Only allow our CDN URLs
    return 'url('; 
  });
  
  // Scope all selectors
  return scopeCSS(css, '.user-content');
};
```

### Security Checklist
- [x] All user input validated with Zod
- [x] SQL injection impossible (parameterized queries)
- [x] XSS protection (React escaping + CSP headers)
- [x] CSRF tokens on state-changing operations
- [x] Rate limiting on all endpoints
- [x] Stripe webhook signature verification
- [x] Image upload virus scanning (via Cloudflare)
- [x] Dependency scanning with Snyk
- [x] Secret rotation every 90 days

---

## 🚀 PERFORMANCE ARCHITECTURE

### Page Load Budget
```yaml
Target Metrics:
  - First Contentful Paint: <1.0s
  - Time to Interactive: <2.5s
  - Lighthouse Score: >90
  - Bundle Size: <200KB (initial)
```

### Optimization Strategy
```typescript
// 1. Static Generation for campaign pages
export async function generateStaticParams() {
  // Pre-render top 100 campaigns
  const campaigns = await getTopCampaigns(100);
  return campaigns.map(c => ({ slug: c.slug }));
}

// 2. Optimistic UI updates
const handleOrder = async () => {
  // Update UI immediately
  setOrderCount(prev => prev + 1);
  
  try {
    await placeOrder();
  } catch (error) {
    // Rollback on failure
    setOrderCount(prev => prev - 1);
  }
};

// 3. Image optimization
import Image from 'next/image';
<Image 
  src={productImage}
  placeholder="blur"
  loading="lazy"
  quality={85}
/>

// 4. Code splitting
const CustomizerModal = lazy(() => import('./CustomizerModal'));
```

### Caching Strategy
```yaml
CDN (Cloudflare):
  - Static assets: 1 year
  - API responses: 60 seconds (stale-while-revalidate)
  - Campaign pages: 5 minutes

Database:
  - Redis for session data
  - Materialized views for analytics
  - Connection pooling (25 connections)

Application:
  - React Query for API caching
  - Service Worker for offline support
```

---

## 📊 MONITORING & OBSERVABILITY

### The Dashboard We Check Every Morning
```typescript
// Sentry for errors
Sentry.init({
  dsn: process.env.SENTRY_DSN,
  tracesSampleRate: 0.1, // 10% sampling
  beforeSend(event) {
    // Strip PII
    delete event.user?.email;
    return event;
  }
});

// Vercel Analytics for performance
import { Analytics } from '@vercel/analytics/react';

// Custom business metrics
const trackEvent = (event: string, properties?: any) => {
  // PostHog for product analytics
  posthog.capture(event, properties);
  
  // Critical business events to Slack
  if (event === 'campaign_successful') {
    notifySlack(`🎉 Campaign ${properties.id} hit goal!`);
  }
};
```

### Alert Thresholds
```yaml
P0 (Wake up the CEO):
  - Payment processing down
  - Database down
  - 500 errors > 1% of traffic

P1 (Wake up engineering):
  - API response time > 2s (p95)
  - Error rate > 0.5%
  - Campaign creation failing

P2 (Fix in the morning):
  - Conversion rate drops 20%
  - Page load > 3s
  - Disk usage > 80%
```

---

## 🔄 SCALING ARCHITECTURE

### The Growth Triggers
```yaml
When to scale what:
  100 users: Current architecture
  1,000 users: Add Redis cache
  10,000 users: Read replicas
  100,000 users: Dedicated infrastructure
  1,000,000 users: Multi-region deployment
```

### Pre-Scale Preparation
```typescript
// 1. Feature flags for gradual rollout
const FEATURES = {
  customCSS: process.env.ENABLE_CUSTOM_CSS === 'true',
  videoBackgrounds: getFeatureFlag('video_backgrounds'),
};

// 2. Database indexes ready
CREATE INDEX CONCURRENTLY idx_campaigns_trending 
ON campaigns(view_count, created_at) 
WHERE status = 'active';

// 3. API versioning from day 1
app.use('/api/v1', v1Routes);
// Future: /api/v2

// 4. Event-driven architecture prep
const publishEvent = async (event: CampaignEvent) => {
  // Start with direct calls
  await updateCounter(event);
  await notifyBuyers(event);
  
  // Later: Replace with message queue
  // await queue.publish('campaign.updated', event);
};
```

---

## 🚢 DEPLOYMENT ARCHITECTURE

### The CI/CD Pipeline
```yaml
# .github/workflows/deploy.yml
name: Deploy
on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - run: npm test
      - run: npm run test:e2e
      
  deploy:
    needs: test
    steps:
      - run: vercel deploy --prod
      - run: npm run migrate:prod
      - run: npm run smoke-test
```

### Environment Strategy
```yaml
Environments:
  Development:
    - Local Supabase
    - Stripe test mode
    - Vercel preview deploys
    
  Staging:
    - staging.dropwave.io
    - Production database copy
    - Stripe test mode
    - Real phone numbers
    
  Production:
    - dropwave.io
    - Multi-region deployment
    - Stripe live mode
    - 24/7 monitoring
```

### Rollback Strategy
```typescript
// Feature flags for instant rollback
if (isFeatureEnabled('new_checkout_flow')) {
  return <NewCheckout />;
} else {
  return <OldCheckout />;
}

// Database migrations are reversible
exports.up = async (knex) => {
  await knex.schema.table('campaigns', table => {
    table.integer('boost_tier').defaultTo(0);
  });
};

exports.down = async (knex) => {
  await knex.schema.table('campaigns', table => {
    table.dropColumn('boost_tier');
  });
};
```

---

## 🏃 DEVELOPMENT WORKFLOW

### The Sacred Rules
1. **Main branch is always deployable**
2. **Every PR requires review**
3. **Tests must pass before merge**
4. **Deployment happens automatically**
5. **Rollback takes <1 minute**

### Local Development Setup
```bash
# One command to rule them all
npm run dev:all

# This starts:
# - Next.js dev server (port 3000)
# - Supabase local (port 54321)
# - Stripe webhook listener
# - Email preview (port 54324)
```

### Code Standards
```typescript
// TypeScript strict mode - no any!
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true
  }
}

// Prettier + ESLint on save
{
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  }
}
```

---

## 💰 COST ARCHITECTURE

### Monthly Costs (MVP)
```yaml
Fixed Costs:
  Vercel Pro: $20
  Supabase Pro: $25
  Cloudflare Pro: $20
  Sentry: $26
  Total: ~$91/month

Variable Costs:
  Stripe: 2.9% + $0.30 per transaction
  SMS (Twilio): $0.0075 per SMS
  Email (Resend): $0.001 per email
  Storage (R2): $0.015 per GB
```

### Cost Optimization
```typescript
// 1. Cache everything cacheable
const getCampaign = unstable_cache(
  async (slug: string) => {
    return db.campaign.findUnique({ where: { slug } });
  },
  ['campaign'],
  { revalidate: 60 } // 1 minute cache
);

// 2. Lazy load expensive operations
if (userWantsAnalytics) {
  const analytics = await import('./analytics');
  analytics.calculate();
}

// 3. Use edge functions for light operations
export const config = {
  runtime: 'edge', // Cheaper than Node.js
};
```

---

## 🚨 DISASTER RECOVERY

### Backup Strategy
```yaml
Automated Backups:
  Database: Every 6 hours (Supabase)
  User uploads: Real-time (S3 cross-region)
  Configuration: Git (version controlled)
  
Recovery Time Objectives:
  Database failure: <1 hour
  Region failure: <4 hours
  Complete disaster: <24 hours
```

### Incident Response
```yaml
Playbooks:
  - Payment_Processing_Down.md
  - Database_Overload.md
  - Viral_Campaign_Traffic_Spike.md
  - Security_Breach.md
  
On-Call Rotation:
  - Primary: Senior Engineer
  - Secondary: CTO
  - Escalation: CEO (for P0 only)
```

---

## ⚡ QUICK DECISIONS GUIDE

### Use Boring Tech For:
- Authentication → Clerk
- Payments → Stripe
- Database → PostgreSQL
- Hosting → Vercel
- Email → Resend

### Build Custom For:
- Campaign logic (core value)
- Customization engine (differentiation)
- Viral mechanics (growth engine)
- Real-time updates (user experience)

### Buy, Don't Build:
- ❌ Custom CDN → Use Cloudflare
- ❌ Custom analytics → Use PostHog
- ❌ Custom email infrastructure → Use Resend
- ❌ Custom payment processing → Use Stripe
- ❌ Custom authentication → Use Clerk

---

## 📋 LAUNCH CHECKLIST

### Week -1: Pre-Launch
- [ ] Load test with 10,000 concurrent users
- [ ] Security audit with Burp Suite
- [ ] Backup restoration drill
- [ ] Monitoring dashboard ready
- [ ] On-call schedule set

### Day 0: Launch
- [ ] Feature flags for quick disable
- [ ] Slack alerts configured
- [ ] Scale settings on auto
- [ ] Support team briefed
- [ ] Celebration champagne chilled 🍾

### Day 1: Post-Launch
- [ ] Review error logs
- [ ] Check conversion funnel
- [ ] Gather user feedback
- [ ] Fix critical bugs only
- [ ] Sleep (finally)

---

## 🎯 NORTH STAR TECHNICAL METRICS

**The Only Numbers That Matter Week 1:**
1. **Uptime: >99.9%**
2. **Payment Success Rate: >95%**
3. **Page Load: <2 seconds**
4. **Error Rate: <0.1%**
5. **Campaign Creation: <2 minutes**

---

**Remember:** Perfect is the enemy of shipped. This architecture gets us to market fast, scales to Series A, and doesn't wake us up at 3am. Everything else is a distraction.

**The Golden Rule:** *If it's not about creators getting paid or buyers feeling special, it can wait until v2.*

Ready to start building, or should we dive deeper into any specific technical component?